# Event loop của NodeJS
Trong nodejs có 1 event loop: nó check liên tục nếu event queue có event + stack trống thì sẽ add vào stack để thực hiện. Tuy nhiên event được add vào queue có thứ tự.
Vc add event vào queue nó phải check liên tục, cứ có là add. Nhưng check theo vòng lặp sau: Timer event(timeout,interval) -> IO callback-> Idle(nội bộ k qt)-> Poll(Tìm kiếm sự kiện IO mới đang polling) -> Check(xử lý callback của setImmediate)-> Close Callbacks(xử lý các callback ngắt kết nối) -> quay lại Timer

=> refer "Tổng kết module JS / Các hàm async với thời gian"

-> Ranh giới C++ và JS: khi có event -> nó gửi event đó đi cho code C++ xử lý và xử lý xong sẽ gửi callback hàm cần thực hiện vào event queue của JS. Với các hàm k làm gì với C++ cả thg thì sẽ trả 1 phát hết cho event queue luôn theo thứ tự

-> Phân biệt:
VD: ta gọi setImmediate và setTimeout 0s cạnh nhau thì quá ngắn nó coi là cùng lúc. Khi đó thứ tự sẽ phụ thuộc vào may rủi và hiệu suất CT nx -> nếu cái vòng lặp thêm event vào queue kia đang chạy ở giai đoạn Check hay là Timer thì sẽ add sự kiện đó vào queue trước => thành ra là lúc Timeout trước, lúc thì Immediate trước.

VD: ta cho setImmediate và setTimeout 0s vào vào 1 luồng IO/callback là fs.readFile chẳng hạn thì chắc chắn Immediate sẽ thực hiện trước setTimeout
=> NN là vì nó chạy vào IO/callback gặp 2 sự kiện đồng thời sẽ thêm callback của setImmediate vào trước vì nó sang giai đoạn Check trước giai đoạn Timer kể từ IO/callback. Tức là mỗi hàm thì nó xử lý vào giai đoạn khác nhau, setImmediate xử lý khi event queue chạy vào Check, còn setTimeout xử lý trong giai đoạn Timer
=> Riêng các callback của nextTickQueue được thực hiện sau khi bất cứ 1 tiến trình nào đang diễn ra hoàn thành(dù kp là tuyệt đối lúc nào cũng v). Tức callback của process.nextTick thường là thực hiện sớm nhất khi xử lý bất cứ 1 cái gì xong đều add nó vào luôn

-> Callback trong nodejs cx tương tự như callback trong js 
Nó giúp giải quyết vấn đề về lấy kết quả của lập trình đa luồng. VD ta làm vc gì lâu trong thời gian chờ, ta làm vc khác, đến khi vc kia xong thì hiện tại ta sẽ lấy được giá trị trả về của vc ban đầu thông qua callback NodeJS. Có rất nhiều module cung các hàm đồng bộ mặc định, còn hàm bất đồng bộ sẽ có chữ async ở cuối và hiểu đc nó là mấu chốt của nodejs. VD promise của js có hàm then lấy kết quả trả về của hàm bất đồng bộ, cơ chế đó chính là callback function lấy kết quả đó. 
Tương tự làm vc với async luôn có các vấn đề mà ta phải gặp như đã biết khi học qt: thực hiện xong mới đc sử dụng dữ liệu (promise ở trạng thái pennding k thể lấy đc); đang truy cập vào biến thì nơi khác k đc dùng; thực hiện xong mới đc thực hiện hàm đó tiếp; kiểm soát qtr thực hiện, dừng lúc nào nếu muốn, thực hiện sau 1 ktg bất kỳ nếu thích,... Callback khi được schedule để thực hiện sẽ được nhét vào event loop

-> Phân tích về event của javascript: Có các thứ là JS engine(stack, heap), web APIs, event loop, event emitter, callback queue, C++ Thread Pool, core, event, call back function/listener
JS tận dụng được sức mạnh của phần cứng, nhờ đó mà NodeJS dùng JS có rất nhiều lợi ích. Bất cứ ngôn ngữ nào cx đều phải biên dịch code ra mã máy, load lên memory chạy từng dòng lệnh, ghi tạm dữ liệu vào bộ nhớ đệm or ổ đĩa r giao tiếp vói các thiết bị IO. Phân tích:
stack: nơi chứa các lệnh nó chạy theo thứ tự LIFO từ code của ta, thực hiện hàm lần lượt gọi là call stack
heap: nơi chứa các kết quả tạm phục vụ cho việc thực thi các hàm trong stack. Heap càng lớn thì tính toán càng nhanh. Trong C/C++ thì dùng nó là cấp phát động 
JS engine: là nền tảng thông dịch mã JS bao gồm heap và stack. NodeJS xây dựng trên JS engine là V8 Chorme
event emitter: là cái phát ra event
event: là thứ chứa các thông tin về sự kiện chờ xử lý
callback function và listener: là cái bind cùng với event, là cái sẽ được thực hiện khi event đó được gọi. 
EventLoop: event loop tồn tại trong Ct vĩnh viễn miễn CT chưa bị tắt. 
Mã nguồn core của nodejs: bao gồm 2 thành phần là javascript và C++ => C++ bao gồm các xử lý tới các thư viện bên ngoài quan trọng như V8, libuv. Nó là kiến trúc cơ bản của NodeJS.
Mã nguồn của ta thực hiện tuần tự trong V8 là thứ bao gồm heap và stack đó, gặp hàm thì đưa vào stack và thực hiện, dữ liệu hàm trả ra lưu vào heap. Nếu k có hàm bất đồng bộ thì sẽ thực hiện tuần tự r kết thúc. Nếu có hàm bất động bộ như callback, sự kiện,.. thì lời gọi đó như 1 request xử lý trong OS hoặc thực thi các WebAPI(lời gọi này quản lý bởi libuv của C++), lúc này stack kia vẫn thực hiện bth còn cái request kia đồng thời bị đẩy ra ngoài độc lập như v nhờ WebAPIs or có thể hiểu là 1 event từ client gửi tới server Nodejs. Request này sẽ được core của CPU thực hiện, cái này do C++ dùng thread pool xử lý nên các tác vụ ở đây được xử lý đồng thời rồi mới đưa vào event queue(VD nếu ta dùng setTimeout 5s thì WebAPIs sẽ k gửi ngay mà 5s sau mới gửi hàm cho queue, nếu ta fetch API thì multithread của CPU sẽ xử lý). CV tốn thời gian đó sẽ được xử lý trên C++ Thread Pool, tức là xử lý multithread và còn cho phép ta tương tác với database, file system,.. Cái nào xong trước thì callback của nó sẽ được đưa vào event queue. Lúc này thứ trong event queue là các hàm callback cần thực hiện. Event loop kiểm tra nếu stack trống thì kiểm tra callback queue, stackqueue k có sự kiện thì loop vẫn có nhưng chả làm gì, nếu event queue có sự kiện thì nó sẽ xử lý. Nó sẽ xử lý yêu cầu và xác định hàm callback của yêu cầu đó gửi vào callstack để xử lý. Size mặc định của libuv thg mặc định là 4(vẫn ở trong libuv của C++). Nếu callstack vẫn có dữ liệu thì eventqueue sẽ k làm gì cả, chờ stack thực hiện callback event đó xong trống mới vô đc, do đó nếu đưa vào event queue mà k đc thực hiện ngay vì trong queue đó có các thứ khác thì thời gian thực hiện có thể lâu hơn dẫn đến setTimeout chỉ là thời gian tối thiểu công việc chạy chứ kp thời gian chính xác.
Ở các ngôn ngữ khác thì mỗi request/event sẽ sinh ra 1 thread riêng xử lý, hoạt động độc lập, được cấp bộ nhớ. Mà thread là thứ tốn tài nguyên nên k hiệu quả. Nhưng trong NodeJS nó xử lý cả ngàn request 1 lúc mặc dù chỉ dùng 1 thread duy nhất. Nó tận dụng con chip đa nhân trên phần cứng. Các web APIs là thứ giúp đẩy các việc ra ngoài chỉ cần event và handler(callback or listener) của nó. Kể cả k có web APIs thì NodeJS vẫn có các cơ chế tương đương thực hiện điều đó. Event Loop trong js giống với event loop trong qt v, chạy hết rồi nhưng vẫn còn 1 vòng lặp event chờ bắt các signal liên tục. Thì ở trong js có 1 cái vòng lặp bắt sự kiện mọi lúc kiểu while(chưa kết thúc){có sự kiện thì thực hiện sự kiện}.
Event Loop là nơi thực thi sự kiện liên tục. Nó thực hiện trong stack lần lượt và nếu stack hết, Ct k tắt đi mà sẽ kiểm tra event queue có thì lại add vào stack và thực hiện. Nếu cả 2 đều trống thì nó cứ quay vòng chả làm gì, lại chờ sự kiện như v.
Điều này đồng nghĩa ở lần load đầu tiên stack k bh trống nên event queue sẽ k được thực hiện nhưng ta lo làm éo gì vì lần đầu load trang chạy rất nhanh xong luôn. 
Như v VD nó gặp hàm setTimeout thì ta k mất công chờ mà thực hiện tiếp luôn, xử lý async bằng cách đưa vào multithread pool, thực hiện trên các core khác nhau. Sự kiện đối với NodeJS nó chỉ là 1 request bind với 1 hàm số, còn trong các ngôn ngữ khác nó là 1 cái gì rất to lớn được cấp vùng nhớ và thread riêng. Và chú ý là thread pool trong js nó k phải 1 pool thực hiện 1 registered function đâu mà là 1 thread nhiều function(1 thread chính duy nhất) cx đc nên có thể xử lý hàng ngàn sự kiện 1 lúc trong 1 luồng chỉ bằng hàng đợi event queue và pool. event loop chính là 1 single thread chạy while(true) mà thôi.
VD cụ thể: ấn nút gọi setTimeout gọi hàm fetch API xong callback in ra màn hình. Compile đến sự kiện -> web APIs lưu nó -> emitter phát sự kiện -> web APIs bắt sự kiện -> đưa cho C++ thread pool xử lý, lúc này nó chả làm gì mà gửi luôn call back của sự kiện cho event queue. Trong lúc này Ct vẫn chạy đồng thời các sự kiện khác và bất đồng bộ thì vẫn đưa vào C++ thread pool xử lý, cái này với cái kia, cái nào xong trước thì gửi vào event queue trước thôi. Event loop lấy nó gửi sang stack. Stack thực hiện nó lại thấy 1 hàm bất đồng bộ là setTimeout lại gửi sang cho WebAPIs. Còn các hàm đồng bộ khác bên trong nó thì vẫn thực hiện tiếp. WebAPIs gửi nó cho thread pool xử lý. Sau ktg set Timeout pool đó sẽ đưa hàm callback của setTimeout vào queue r vào stack nếu stack trống r thực hiện -> thực hiện thì lại bắt gặp hàm fetch API -> lại đưa sang WebAPIs, nó lại đưa vào pool xử lý bất đồng bộ. Lúc này stack trống và có thể thực hiện tiếp các hàm khác. Pool thực hiện xong sẽ lại đưa callback của hàm đó vào event queue -> event loop lại lấy ra đưa vào stack để thực hiện nếu stack trống, lúc này sẽ thực hiện in ra màn hình

